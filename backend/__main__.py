"""
Multi-Agent Playground - FastAPI Backend Server
==============================================
Main entry point for the FastAPI backend that handles agent simulation.

This file defines the core API endpoints that enable communication between
the frontend (Godot) and the backend agent system. It provides endpoints for:
- Planning agent actions based on current perception
- Confirming and updating agent state after action execution
- Retrieving current agent state

The server follows a two-step action protocol:
1. /agent_act/plan - Get next action plan from agent
2. /agent_act/confirm - Confirm execution and update agent memory
"""
from dotenv import load_dotenv
load_dotenv()
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from backend.config.schema import AgentActionInput, AgentActionOutput, AgentPerception, StatusMsg
from backend.server.controller import plan_next_action, confirm_action_and_update


app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Restrict in production!
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.post("/agent_act/plan", response_model=AgentActionOutput)
def post_plan_action(agent_id: str, perception: AgentPerception):
    """
    Step 1: Receives current agent perception from frontend,
    asks the LLM/planner for the next action, and returns that action to the frontend.
    (Does NOT update agent state or memory!)
    for frontend, we now have agent_id in query_param and + perception in json body; may need to update to make it consistent
    """
    return plan_next_action(agent_id, perception)


@app.post("/agent_act/confirm", response_model=StatusMsg)
def post_confirm_action(agent_msg: AgentActionInput):
    """
    Step 2: Receives the agent's executed action and the resulting world state from frontend.
    Now commits updates to agent state/memory and returns the (new) state to frontend.
    for this func, it has all data in the json body.
    """
    confirm_action_and_update(agent_msg)
    return StatusMsg(status="ok")

# I dont think we need this function rn
# @app.get("/agent_state/", response_model=AgentActionOutput)
# def get_agent_state(agent_id: str):
#     from character_agent.agent import Agent
#     agent = Agent(agent_id)
#     # Provide current state (may expand as needed)
#     return AgentActionOutput(
#         agent_id=agent.agent_id,
#         action_type="perceive",
#         content={},
#         emoji="ðŸ‘€",
#         current_tile=agent.curr_tile,
#         current_location=getattr(agent, "current_location", None)
#     )

# For first time run:
"""
On simulation start, the frontend POSTs to /agent_act/ with:

The initial world perception (could be "empty" or the initial environment)

Usually, no action or an action_type="perceive".

Backend:
Receives the perception, but no action has yet occurred.

Questions:
Should salience (action importance) always be generated by the LLM at the time of action planning, or should 
it be assigned after action is executed in frontend and perceived by the agent? If so , how should we implement that?
"""